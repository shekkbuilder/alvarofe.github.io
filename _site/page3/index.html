<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Álvaro Felipe Melchor &middot; Stuff about everything
    
    Álvaro Felipe Melchor
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/pic.png">
                                 <link rel="shortcut icon" href="/public/pic.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!--<link rel="stylesheet" href="/public/css/highlight/styles/monokai.css">
  <script src="/public/css/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>-->

</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Álvaro Felipe Melchor
        </a>
      </h1>
      <p class="lead">Stuff about everything</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about.html">About</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/archive.html">Archive</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="https://github.com/alvarofe">GitHub</a>
    </nav>

    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/posts/doublylist">
        How Linux Implements Generic List
      </a>
    </h1>

    <span class="post-date">18 Dec 2014</span>

    <p>I was reading <a href="http://shop.oreilly.com/product/9780596005658.do">Understanding the Linux Kernel</a> about how each process is represented through <code>task_struct</code> and so on. The kernel uses a lot of struct to represent different kind of data and it uses lists to manage relationship between them. It would be a waste of time that for each kind of struct was necessary develop a new list, functions to handle it … etc. To resolve this, Linux makes use of a generic list. The idea is as follows.</p>

<p><img src="/public/images/linked-list.png" alt="linked-list"></p>

<p>If you want that your struct be in a list all what you have to do is include a <code>list_head</code> inside it. <code>list_head</code> is defined as follows (I am using the source code of Linux 2.6.0).</p>
<div class="highlight"><pre><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">list_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Where <code>next</code> and <code>prev</code> point to the next and previous element in the list respectively. The first question that has came to me is how are we able to get the pointer to the real struct if we only have a pointer to <code>list_head</code>?. The solution provided by Linux is very clever. Before to know is better to have better context about a real struct used by Linux as <code>task_struct</code>.</p>
<div class="highlight"><pre><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="k">volatile</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>    <span class="cm">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
    <span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">thread_info</span><span class="p">;</span>
    <span class="kt">atomic_t</span> <span class="n">usage</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>    <span class="cm">/* per process flags, defined below */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptrace</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">lock_depth</span><span class="p">;</span>     <span class="cm">/* Lock depth */</span>

    <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="n">static_prio</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">run_list</span><span class="p">;</span>
    <span class="kt">prio_array_t</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sleep_avg</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">interactive_credit</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">activated</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">policy</span><span class="p">;</span>
    <span class="kt">cpumask_t</span> <span class="n">cpus_allowed</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_slice</span><span class="p">,</span> <span class="n">first_time_slice</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>

    <span class="cm">/* there are more types*/</span>
  <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>You can see how inside the <code>task_struct</code> has a member whose name is <code>task</code> of type <code>list_head</code>. This is used to track each process that run inside the kernel so through this member we can  retrieve all the process. There is a macro inside the Linux Kernel to run through all the process.</p>
<div class="highlight"><pre><code class="language-C" data-lang="C"><span class="cp">#define next_task(p)    list_entry((p)-&gt;tasks.next, struct task_struct, tasks)</span>

<span class="cp">#define for_each_process(p) \</span>
<span class="cp">    for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; )</span>
</code></pre></div>
<p>In <code>list_entry</code> is where we are going to get in this case the pointer to <code>task_struct</code>.</p>
<div class="highlight"><pre><code class="language-C" data-lang="C"><span class="cm">/**</span>
<span class="cm"> * list_entry - get the struct for this entry</span>
<span class="cm"> * @ptr:    the &amp;struct list_head pointer.</span>
<span class="cm"> * @type:   the type of the struct this is embedded in.</span>
<span class="cm"> * @member: the name of the list_struct within the struct.</span>
<span class="cm"> */</span>
<span class="cp">#define list_entry(ptr, type, member) \</span>
<span class="cp">    container_of(ptr, type, member)</span>

<span class="o">**</span>
 <span class="o">*</span> <span class="n">container_of</span> <span class="o">-</span> <span class="n">cast</span> <span class="n">a</span> <span class="n">member</span> <span class="n">of</span> <span class="n">a</span> <span class="n">structure</span> <span class="n">out</span> <span class="n">to</span> <span class="n">the</span> <span class="n">containing</span> <span class="n">structure</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="err">@</span><span class="nl">ptr</span><span class="p">:</span>    <span class="n">the</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">member</span><span class="p">.</span>
 <span class="o">*</span> <span class="err">@</span><span class="nl">type</span><span class="p">:</span>   <span class="n">the</span> <span class="n">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">container</span> <span class="k">struct</span> <span class="n">this</span> <span class="n">is</span> <span class="n">embedded</span> <span class="n">in</span><span class="p">.</span>
 <span class="o">*</span> <span class="err">@</span><span class="nl">member</span><span class="p">:</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">member</span> <span class="n">within</span> <span class="n">the</span> <span class="k">struct</span><span class="p">.</span>
 <span class="o">*</span>
 <span class="err">*/</span>
<span class="cp">#define container_of(ptr, type, member) ({          \</span>
<span class="cp">        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span>
<span class="cp">        (type *)( (char *)__mptr - offsetof(type,member) );})</span>
</code></pre></div>
<p>The magic really happens in <code>container_of</code> and is really simple. The first line declares <code>__mptr</code> equal to the type of the <code>member</code> inside the <code>type</code> and is assigned <code>ptr</code> that in our case would be <code>task</code> of the actual process. The second line   subtract the address of <code>__mptr</code> the offset between the <code>task_struct</code> and the member <code>task</code>, thanks to that you are able to get a reference to the <code>task_struct</code> through <code>task</code>.</p>

<p>Maybe is a little bit confusing at the beginning but once you get used to it, is very useful since you can apply the same idea to your projects. You should check this out <a href="https://github.com/torvalds/linux/blob/master/include/linux/list.h">/include/linux/list.h</a> and seeing the rest of the functions that Linux uses to manipulate list.</p>

<p>If you liked this post, you can
<a href="https://twitter.com/intent/tweet/?url=http://alvarofe.github.io/posts/doublylist&text=How Linux Implements Generic List&via=alvaro_fe">share it with your followers</a>
or
<a href="https://twitter.com/alvaro_fe"> follow me on Twitter</a>!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/posts/protostartstack0">
        Stack 0 Protostart
      </a>
    </h1>

    <span class="post-date">14 Dec 2014</span>

    <p>I have started to play with the protostar VM along with nebula. This VM presents the concept about the memory issues as buffer overflows in stack and in the heap, format string and so on.</p>

<p>The first exercise present a buffer overflow. The code is as follows.</p>
<div class="highlight"><pre><code class="language-C" data-lang="C"><span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">modified</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

  <span class="n">modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">modified</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;you have changed the &#39;modified&#39; variable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Try again?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>To resolve this puzzle we should have clear how is carried out the flow execution of a program. In the C language the stack is a structure that is used to pass argument to the function, save return address and also to save the local variables. So in the following C code the stack would be.</p>
<div class="highlight"><pre><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">The stack grows downwards

+————————————+
| argument b |  The local variables are saved in reverse order.
+————————————+
| argument a |
+————————————+
| return     |  The return address is saved automatically by the 
| address    |  call instruction in assembly.
+————————————+
|            |  The base pointer register. Is used to reference 
|    EBP     |  inside the function without calculate offset 
|            |  respect with the ESP.
+————————————+
|  local c   |
+————————————+
</code></pre></div>
<p>The stack in the main function is.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">+————————————+
| argument 2 |  
+————————————+
| argument 1 |
+————————————+
| return     |  
| address    |  
+————————————+
|            |   
|    EBP     |   
|            |  
+————————————+
|  modified  |
+————————————+
|  buffer    |
+————————————+
</code></pre></div>
<p>So if we are able to write more than 64 bytes in buffer we can overwrite the value in <code>modified</code>. But Are we able to achieve that? The answers is yes due to the code is using an insecure function <code>gets</code>. It does not limit the input so we are able to write more than 64 bytes. So with the following we can change the value.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span> <span class="nb">printf</span> <span class="s2">&quot;%065x&quot;</span> 1
00000000000000000000000000000000000000000000000000000000000000001
<span class="nv">$ </span>./stack0
00000000000000000000000000000000000000000000000000000000000000001
you have changed the <span class="s1">&#39;modified&#39;</span> variable
</code></pre></div>
<p>If you want to augment your knowledge about stack and how to exploit it I encourage to read the article <a href="http://q.hscott.net/reads/stack_smashing.pdf">Smash the Stack For Fun And Profit by Aleph One</a></p>

<p>If you liked this post, you can
<a href="https://twitter.com/intent/tweet/?url=http://alvarofe.github.io/posts/protostartstack0&text=Stack 0 Protostart&via=alvaro_fe">share it with your followers</a>
or
<a href="https://twitter.com/alvaro_fe"> follow me on Twitter</a>!</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page4">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page2">Newer</a>
    
  
</div>
    </div>

    

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57722858-1', 'auto');
  ga('send', 'pageview');

</script>


  </body>
</html>
